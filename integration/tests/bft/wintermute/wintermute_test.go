package wintermute

import (
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	"github.com/onflow/flow-go/model/flow"
)

// wintermuteTimeout corresponds to the timeout the wintermute orchestrator have to conduct the attack.
const wintermuteTimeout = 1 * time.Minute

type WintermuteTestSuit struct {
	Suite
}

func TestWintermuteAttackTestSuite(t *testing.T) {
	suite.Run(t, new(WintermuteTestSuit))
}

func (w *WintermuteTestSuit) TestWintermuteAttack() {

	corruptedResult := w.waitForExecutionResultCorruption()

	block := w.BlockState.WaitForBlockById(w.T(), corruptedResult.BlockID)

	// waits for the execution receipt of blockB from both execution nodes, and makes sure that there is no execution fork.
	receiptB1 := w.ReceiptState.WaitForReceiptFrom(w.T(), block.Header.ID(), w.exe1ID)
	w.T().Logf("receipt for block generated by execution node-1: %x result ID: %x\n", w.exe1ID, receiptB1.ExecutionResult.ID())
	receiptB2 := w.ReceiptState.WaitForReceiptFrom(w.T(), block.Header.ID(), w.exe2ID)
	w.T().Logf("receipt for block generated by execution node-2: %x result ID: %x\n", w.exe2ID, receiptB2.ExecutionResult.ID())

	for i := 0; i < len(corruptedResult.Chunks); i++ {
		w.ApprovalState.WaitForResultApproval(w.T(), w.verID, corruptedResult.ID(), uint64(i))
	}

	w.BlockState.WaitForSealed(w.T(), block.Header.Height)
}

func (w *WintermuteTestSuit) waitForExecutionResultCorruption() *flow.ExecutionResult {
	var corruptedResult *flow.ExecutionResult

	require.Eventually(w.T(), func() bool {
		corrupted, original, conducted := w.Orchestrator.AttackState()
		if !conducted {
			w.T().Logf("pending wintermute orchestrator to conduct attack")
			return false
		}

		corruptedResult = &corrupted

		w.T().Logf("wintermute orchesterator conducted corruption, original result: %x, corrupted result: %x", original.ID(), corrupted.ID())
		return true
	}, wintermuteTimeout, 100*time.Millisecond,
		fmt.Sprintf("orchestrator could not conduct execution result corruption within %v seconds", wintermuteTimeout))

	return corruptedResult
}
